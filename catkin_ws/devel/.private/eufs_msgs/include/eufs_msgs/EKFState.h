// Generated by gencpp from file eufs_msgs/EKFState.msg
// DO NOT EDIT!


#ifndef EUFS_MSGS_MESSAGE_EKFSTATE_H
#define EUFS_MSGS_MESSAGE_EKFSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace eufs_msgs
{
template <class ContainerAllocator>
struct EKFState_
{
  typedef EKFState_<ContainerAllocator> Type;

  EKFState_()
    : gps_received(false)
    , imu_received(false)
    , wheel_odom_received(false)
    , ekf_odom_received(false)
    , ekf_accel_received(false)
    , currently_over_covariance_limit(false)
    , consecutive_turns_over_covariance_limit(false)
    , recommends_failure(false)  {
    }
  EKFState_(const ContainerAllocator& _alloc)
    : gps_received(false)
    , imu_received(false)
    , wheel_odom_received(false)
    , ekf_odom_received(false)
    , ekf_accel_received(false)
    , currently_over_covariance_limit(false)
    , consecutive_turns_over_covariance_limit(false)
    , recommends_failure(false)  {
  (void)_alloc;
    }



   typedef uint8_t _gps_received_type;
  _gps_received_type gps_received;

   typedef uint8_t _imu_received_type;
  _imu_received_type imu_received;

   typedef uint8_t _wheel_odom_received_type;
  _wheel_odom_received_type wheel_odom_received;

   typedef uint8_t _ekf_odom_received_type;
  _ekf_odom_received_type ekf_odom_received;

   typedef uint8_t _ekf_accel_received_type;
  _ekf_accel_received_type ekf_accel_received;

   typedef uint8_t _currently_over_covariance_limit_type;
  _currently_over_covariance_limit_type currently_over_covariance_limit;

   typedef uint8_t _consecutive_turns_over_covariance_limit_type;
  _consecutive_turns_over_covariance_limit_type consecutive_turns_over_covariance_limit;

   typedef uint8_t _recommends_failure_type;
  _recommends_failure_type recommends_failure;





  typedef boost::shared_ptr< ::eufs_msgs::EKFState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::eufs_msgs::EKFState_<ContainerAllocator> const> ConstPtr;

}; // struct EKFState_

typedef ::eufs_msgs::EKFState_<std::allocator<void> > EKFState;

typedef boost::shared_ptr< ::eufs_msgs::EKFState > EKFStatePtr;
typedef boost::shared_ptr< ::eufs_msgs::EKFState const> EKFStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::eufs_msgs::EKFState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::eufs_msgs::EKFState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::eufs_msgs::EKFState_<ContainerAllocator1> & lhs, const ::eufs_msgs::EKFState_<ContainerAllocator2> & rhs)
{
  return lhs.gps_received == rhs.gps_received &&
    lhs.imu_received == rhs.imu_received &&
    lhs.wheel_odom_received == rhs.wheel_odom_received &&
    lhs.ekf_odom_received == rhs.ekf_odom_received &&
    lhs.ekf_accel_received == rhs.ekf_accel_received &&
    lhs.currently_over_covariance_limit == rhs.currently_over_covariance_limit &&
    lhs.consecutive_turns_over_covariance_limit == rhs.consecutive_turns_over_covariance_limit &&
    lhs.recommends_failure == rhs.recommends_failure;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::eufs_msgs::EKFState_<ContainerAllocator1> & lhs, const ::eufs_msgs::EKFState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace eufs_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::eufs_msgs::EKFState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::eufs_msgs::EKFState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::eufs_msgs::EKFState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::eufs_msgs::EKFState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::eufs_msgs::EKFState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::eufs_msgs::EKFState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::eufs_msgs::EKFState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "08d63999f28c68f92f4728fef441c767";
  }

  static const char* value(const ::eufs_msgs::EKFState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x08d63999f28c68f9ULL;
  static const uint64_t static_value2 = 0x2f4728fef441c767ULL;
};

template<class ContainerAllocator>
struct DataType< ::eufs_msgs::EKFState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "eufs_msgs/EKFState";
  }

  static const char* value(const ::eufs_msgs::EKFState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::eufs_msgs::EKFState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message contains information about the state of the EKF\n"
"# and is meant for use by the state monitor to ensure the EKF\n"
"# isn't failing.\n"
"\n"
"bool gps_received\n"
"bool imu_received\n"
"bool wheel_odom_received\n"
"\n"
"bool ekf_odom_received\n"
"bool ekf_accel_received\n"
"\n"
"bool currently_over_covariance_limit\n"
"bool consecutive_turns_over_covariance_limit\n"
"\n"
"bool recommends_failure\n"
;
  }

  static const char* value(const ::eufs_msgs::EKFState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::eufs_msgs::EKFState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.gps_received);
      stream.next(m.imu_received);
      stream.next(m.wheel_odom_received);
      stream.next(m.ekf_odom_received);
      stream.next(m.ekf_accel_received);
      stream.next(m.currently_over_covariance_limit);
      stream.next(m.consecutive_turns_over_covariance_limit);
      stream.next(m.recommends_failure);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct EKFState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::eufs_msgs::EKFState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::eufs_msgs::EKFState_<ContainerAllocator>& v)
  {
    s << indent << "gps_received: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gps_received);
    s << indent << "imu_received: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.imu_received);
    s << indent << "wheel_odom_received: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheel_odom_received);
    s << indent << "ekf_odom_received: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ekf_odom_received);
    s << indent << "ekf_accel_received: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ekf_accel_received);
    s << indent << "currently_over_covariance_limit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.currently_over_covariance_limit);
    s << indent << "consecutive_turns_over_covariance_limit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.consecutive_turns_over_covariance_limit);
    s << indent << "recommends_failure: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.recommends_failure);
  }
};

} // namespace message_operations
} // namespace ros

#endif // EUFS_MSGS_MESSAGE_EKFSTATE_H
